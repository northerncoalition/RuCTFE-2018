#!/usr/bin/env python2

from pwn import *
import requests
import json
import re
import time
import os
from multiprocessing.dummy import Pool as ThreadPool
import importlib

# Logging configuration
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

original_info = log.info
log.info = lambda x: original_info(bcolors.OKBLUE + x + bcolors.ENDC)
log.header = lambda x: original_info(bcolors.HEADER + x + bcolors.ENDC)

original_success = log.success
log.success = lambda x: original_success(bcolors.OKGREEN + x + bcolors.ENDC)

original_failure = log.failure
log.failure = lambda x: original_failure(bcolors.FAIL + x + bcolors.ENDC)
log.fail_once = lambda x, errors_in_round: x in errors_in_round or log.failure(x)

# Team information
X_TEAM_TOKEN    = ""
TEAM_NUMBER     = 162 # Taken from https://ructfe.org/teams/

# Submission server URL
SUBMISSION_URL = "http://monitor.ructfe.org/flags"
SUBMISSION_URL = "http://127.0.0.1:1337/flags"

# Message types
NO_SUCH_FLAG        = "Denied: no such flag"
OWN_FLAG            = "Denied: flag is your own"
ALREADY_SUBMITTED   = "Denied: you already submitted this flag"
ACCEPTED            = "\[.+\] Accepted. (.+) flag points"

# Delays and timeouts
REQUEST_TIMEOUT     = 5 # HTTP Request timeouts (in seconds)
RECONNECT_DELAY     = 3 # Delay before attempting a new connection (in seconds)
ROUND_DELAY         = 30 # Seconds between each round

# Miscellaneous
EXPLOIT_FOLDER      = "exploits"
NUMBER_OF_TEAMS     = 174 # Taken from https://ructfe.org/teams/

def is_valid_flag(flag):
    """
    Checks if a string matches the flag format
    Returns the regex match or None
    """
    return re.match("^\w{31}=", flag)

def remove_invalid_flags(flags):
    """
    Takes a list of flags and removes flags with an invalid format
    Returns a list of valid flags (format-wise)
    """

    # Validate flag format
    filtered_flags = [flag for flag in flags if is_valid_flag(flag)]

    number_of_removed_flags = len(flags) - len(filtered_flags)

    if number_of_removed_flags:
        log.failure("Removed {} flags with incorrect format.".format(number_of_removed_flags))

    return filtered_flags

def print_statistics_from_flag_responses(flag_responses, flags_per_handler):

    stats = {}

    for handler in flags_per_handler.keys():
        stats[handler] = {
            "number_of_invalid_flags" : 0,
            "number_of_own_flags" : 0,
            "number_of_already_submitted_flags" : 0,
            "number_of_accepted_flags" : 0,
            "total_points" : 0
        }

    for response in flag_responses:

        current_handler = None

        # Find which handler submitted a given flag
        for handler in flags_per_handler.keys():

            if response['flag'] in flags_per_handler[handler]:
                current_handler = handler

        if not current_handler:
            log.failure("Server responded with a flag that we have never submitted : {}".format(
                response['flag']))
            continue

        if response['message_type'] == NO_SUCH_FLAG:
            stats[current_handler]['number_of_invalid_flags'] += 1

        elif response['message_type'] == OWN_FLAG:
            stats[current_handler]['number_of_own_flags'] += 1

        elif response['message_type'] == ALREADY_SUBMITTED:
            stats[current_handler]['number_of_already_submitted_flags'] += 1

        elif response['message_type'] == ACCEPTED:
            stats[current_handler]['number_of_accepted_flags'] += 1
            stats[current_handler]['total_points'] += response['points']

        else:
            log.failure("Invalid message received : '{}'".format(response['message_type']))

    log.header("==== ROUND STATISTICS ===")
    for handler in stats.keys():
        number_of_invalid_flags = stats[handler]['number_of_invalid_flags']
        number_of_own_flags = stats[handler]['number_of_own_flags']
        number_of_already_submitted_flags = stats[handler]['number_of_already_submitted_flags']
        number_of_accepted_flags = stats[handler]['number_of_accepted_flags']
        total_points = stats[handler]['total_points']

        log.header("{:30} | {:7} | {:3} | {:17} | {:8} | {:20} |".format("Handler name",
            "Invalid", "Own", "Already submitted", "Accepted", "Points"))

        log.header("{:30} | {:7} | {:3} | {:17} | {:8} | {:20} |".format(handler,
            number_of_invalid_flags, number_of_own_flags, number_of_already_submitted_flags,
            number_of_accepted_flags, total_points))

def parse_response(flag_response):
    """
    Parses each individual flag response returned from submit_flags()
    Returns a dictionary containing { flag, is_valid, message_type, points }
    """

    flag            = flag_response['flag']
    is_valid        = flag_response['status']
    message_type    = flag_response['msg']
    points   = 0

    if NO_SUCH_FLAG in flag_response['msg']:
        message_type = NO_SUCH_FLAG

    if OWN_FLAG in flag_response['msg']:
        message_type = OWN_FLAG

    if ALREADY_SUBMITTED in flag_response['msg']:
        message_type = ALREADY_SUBMITTED

    if re.match(ACCEPTED, flag_response['msg']):
        message_type = ACCEPTED
        match = re.match(ACCEPTED, flag_response['msg'])
        points = float(match.groups(0)[0])

    return {
        "flag" : flag,
        "is_valid" : is_valid,
        "message_type" : message_type,
        "points" : points
    }

def submit_flags(flags = []):
    """
    Submit flags to the submission server and parses the responses.
    Returns the parsed flag responses.
    """

    log.success("Submitting {} flags.".format(len(flags)))

    headers = { "X-Team-Token" : X_TEAM_TOKEN }
    response = None

    # Loop until we receive a response from the submission server
    while not response:
        try:
            response = requests.put(SUBMISSION_URL, headers=headers,
                                        json=flags, timeout=REQUEST_TIMEOUT)

        except requests.ConnectionError as e:
            log.failure("Submission server is not up. Re-trying in {} seconds".format(
                RECONNECT_DELAY))
            time.sleep(RECONNECT_DELAY)

        except requests.ReadTimeout as e:
            log.failure("Submission server did not respond in {} seconds. Re-trying.".format(
                REQUEST_TIMEOUT))

        except Exception as e:
            log.failure("An unknown error occured when submitting the flags : {}".format(e))

    json_response = json.loads(response.text)
    flag_responses = [parse_response(response) for response in json_response]

    return flag_responses

def register_handlers():
    """
    Register exploit handlers from the exploit folder
    Returns the list of registered handlers
    """

    exploit_folder = './{}/{}'.format(os.path.dirname(__file__), EXPLOIT_FOLDER)
    handlers = []

    for module in os.listdir(exploit_folder):

        if not module.endswith(".py") or module == "__init__.py":
            continue

        # Execute the script
        # We assume that each executed script registers himself to the handlers dictionary.
        try:
            execfile('./{}/{}'.format(EXPLOIT_FOLDER, module))
        except Exception as e:
            log.failure("Could not register handler '{}' : {}".format(module, e))

    log.info("Registered {} handler(s).".format(len(handlers)))
    for handler in handlers:

        handler_name = handler.__name__
        log.info("- Registered '{}' handler".format(handler_name))

    return handlers

def get_opponent_ips():
    """
    Calculate the IPs of opponent teams.
    Based on the instructions provided here : https://ructfe.org/network/
    """

    for i in range(NUMBER_OF_TEAMS):

        if i == TEAM_NUMBER:
            continue

        C = 80 + i / 256
        B = i % 256
        yield "10.{}.{}.1".format(C, B)

if __name__ == '__main__':

    log.info("Starting exploit throwing framework...")


    # Main round loop
    while True:

        log.header("==== ROUND START ====")

        # Register handlers
        handlers = register_handlers()

        # Dictionary containing a list of flags for each handler
        flags_per_handler = {}

        # Keep track of errors for this round
        errors = set()

        def exploit(opponent_ip):

            flags = []

            # Run each exploit
            for handler in handlers:
                handler_name = handler.__name__

                try:
                    flag = handler.get_flag(opponent_ip)

                    flags.append((handler_name, flag.strip()))

                except Exception as e:
                    error_message = "Service '{}' failed to get flag(s) : {}".format(
                            handler_name, e)

                    log.fail_once(error_message, errors)
                    errors.add(error_message)

            return flags

        # Iterate over each opponent
        pool = ThreadPool(100)
        results = pool.map(exploit, get_opponent_ips())
        pool.close()
        pool.join()

        for l in results:
            for pair in l:
                flags = flags_per_handler.get(pair[0], [])
                flags.append(pair[1])
                flags_per_handler[pair[0]] = flags

        # Log number of flags per handler
        all_flags = []
        for handler in flags_per_handler.keys():

            flags = flags_per_handler.get(handler, [])
            log.success("'{}' handler found {} flag(s).".format(handler, len(flags)))

            all_flags.extend(flags)

        # Filter out flags with incorrect format
        filtered_flags = remove_invalid_flags(all_flags)

        # Send flags to submission server
        flag_responses = submit_flags(filtered_flags)

        # Print statistics
        print_statistics_from_flag_responses(flag_responses, flags_per_handler)

        # Wait for next round
        log.info("Waiting {} seconds before next round".format(ROUND_DELAY))
        time.sleep(ROUND_DELAY)
