#!/usr/bin/env python2

from pwn import *
import requests
import json
import re
import time
import os
import importlib

# Logging configuration
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

original_info = log.info
log.info = lambda x: original_info(bcolors.OKBLUE + x + bcolors.ENDC)

original_success = log.success
log.success = lambda x: original_success(bcolors.OKGREEN + x + bcolors.ENDC)

original_warning = log.warning
log.warning = lambda x: original_warning(bcolors.HEADER + x + bcolors.ENDC)

original_failure = log.failure
log.failure = lambda x: original_failure(bcolors.FAIL + x + bcolors.ENDC)
log.fail_once = lambda x, errors_in_round: x in errors_in_round or log.failure(x)

# Team information
X_TEAM_TOKEN    = ""
TEAM_NUMBER     = 162 # Taken from https://ructfe.org/teams/

# Submission server URL
SUBMISSION_URL = "http://monitor.ructfe.org/flags"
SUBMISSION_URL = "http://127.0.0.1:1337/flags"

# Message types
NO_SUCH_FLAG        = "Denied: no such flag"
OWN_FLAG            = "Denied: flag is your own"
ALREADY_SUBMITTED   = "Denied: you already submitted this flag"
ACCEPTED            = "\[.+\] Accepted. (.+) flag points"

# Delays and timeouts
REQUEST_TIMEOUT     = 5 # HTTP Request timeouts (in seconds)
RECONNECT_DELAY     = 3 # Delay before attempting a new connection (in seconds)
ROUND_DELAY         = 30 # Seconds between each round

# Miscellaneous
EXPLOIT_FOLDER      = "exploits"
NUMBER_OF_TEAMS     = 174 # Taken from https://ructfe.org/teams/

def is_valid_flag(flag):
    """
    Checks if a string matches the flag format
    Returns the regex match or None
    """
    return re.match("^\w{31}=", flag)

def remove_invalid_flags(flags):
    """
    Takes a list of flags and removes flags with an invalid format
    Returns a list of valid flags (format-wise)
    """

    # Remove any trailing whitespace
    filtered_flags = [flag.strip() for flag in flags]

    # Validate flag format
    filtered_flags = [flag for flag in flags if is_valid_flag(flag)]

    number_of_removed_flags = len(flags) - len(filtered_flags)

    if number_of_removed_flags:
        log.failure("Removed {} flags with incorrect format.".format(number_of_removed_flags))

    return filtered_flags

def print_statistics_from_flag_responses(flag_responses):

    # Statistics
    number_of_invalid_flags = 0
    number_of_own_flags = 0
    number_of_already_submitted_flags = 0
    number_of_accepted_flags = 0
    total_points = 0

    for response in flag_responses:

        if response['message_type'] == NO_SUCH_FLAG:
            number_of_invalid_flags += 1

        elif response['message_type'] == OWN_FLAG:
            number_of_own_flags += 1

        elif response['message_type'] == ALREADY_SUBMITTED:
            number_of_already_submitted_flags += 1

        elif response['message_type'] == ACCEPTED:
            number_of_accepted_flags += 1
            total_points += response['points']

        else:
            log.warning("Invalid message received : '{}'".format(response['message_type']))

    log.warning("==== ROUND STATISTICS ===")
    log.info("Number of invalid flags submitted     : {}".format(number_of_invalid_flags))
    log.info("Number of our own flags submitted     : {}".format(number_of_own_flags))
    log.info("Number of already submitted flags     : {}".format(number_of_already_submitted_flags))
    log.info("Number of accepted flags              : {}".format(number_of_accepted_flags))
    log.info("Number of points gained               : {}".format(total_points))

def parse_response(flag_response):
    """
    Parses each individual flag response returned from submit_flags()
    Returns a dictionary containing { flag, is_valid, message_type, points }
    """

    flag            = flag_response['flag']
    is_valid        = flag_response['status']
    message_type    = flag_response['msg']
    points   = 0

    if NO_SUCH_FLAG in flag_response['msg']:
        message_type = NO_SUCH_FLAG

    if OWN_FLAG in flag_response['msg']:
        message_type = OWN_FLAG

    if ALREADY_SUBMITTED in flag_response['msg']:
        message_type = ALREADY_SUBMITTED

    if re.match(ACCEPTED, flag_response['msg']):
        message_type = ACCEPTED
        match = re.match(ACCEPTED, flag_response['msg'])
        points = float(match.groups(0)[0])

    return {
        "flag" : flag,
        "is_valid" : is_valid,
        "message_type" : message_type,
        "points" : points
    }

def submit_flags(flags = []):
    """
    Submit flags to the submission server and parses the responses.
    Returns the parsed flag responses.
    """

    log.success("Submitting {} flags.".format(len(flags)))

    headers = { "X-Team-Token" : X_TEAM_TOKEN }
    response = None

    # Loop until we receive a response from the submission server
    while not response:
        try:
            response = requests.put(SUBMISSION_URL, headers=headers,
                                        json=flags, timeout=REQUEST_TIMEOUT)

        except requests.ConnectionError as e:
            log.warning("Submission server is not up. Re-trying in {} seconds".format(
                RECONNECT_DELAY))
            time.sleep(RECONNECT_DELAY)

        except requests.ReadTimeout as e:
            log.warning("Submission server did not respond in {} seconds. Re-trying.".format(
                REQUEST_TIMEOUT))

        except Exception as e:
            log.warning("An unknown error occured when submitting the flags : {}".format(e))

    json_response = json.loads(response.text)
    flag_responses = [parse_response(response) for response in json_response]

    return flag_responses

def register_handlers():
    """
    Register exploit handlers from the exploit folder
    Returns the list of registered handlers
    """

    exploit_folder = './{}/{}'.format(os.path.dirname(__file__), EXPLOIT_FOLDER)
    handlers = []

    for module in os.listdir(exploit_folder):

        if not module.endswith(".py") or module == "__init__.py":
            continue

        # Execute the script
        # We assume that each executed script registers himself to the handlers dictionary.
        try:
            execfile('./{}/{}'.format(EXPLOIT_FOLDER, module))
        except Exception as e:
            log.warning("Could not register handler '{}' : {}".format(module, e))

    log.info("Registered {} handler(s).".format(len(handlers)))
    for handler in handlers:

        handler_name = handler.__name__
        log.info("- Registered '{}' handler".format(handler_name))

    return handlers

def get_opponent_ips():
    """
    Calculate the IPs of opponent teams.
    Based on the instructions provided here : https://ructfe.org/network/
    """

    for i in range(NUMBER_OF_TEAMS):

        if i == TEAM_NUMBER:
            continue

        C = 80 + i / 256
        B = i % 256
        yield "10.{}.{}.1".format(C, B)

if __name__ == '__main__':

    log.info("Starting exploit throwing framework...")


    # Main round loop
    while True:

        log.warning("==== ROUND START ====")

        # Register handlers
        handlers = register_handlers()

        flags = []

        # Keep track of errors for this round
        errors = set()

        # Iterate over each opponent
        for opponent_ip in get_opponent_ips():

            # Run each exploit
            for handler in handlers:
                handler_name = handler.__name__

                try:
                    flag = handler.get_flag(opponent_ip)
                    flags.append(flag)

                except Exception as e:
                    error_message = "Service '{}' failed to get flag(s) : {}".format(
                            handler_name, e)

                    log.fail_once(error_message, errors)
                    errors.add(error_message)

        log.info("Found {} flags.".format(len(flags)))

        # Filter out flags with incorrect format
        filtered_flags = remove_invalid_flags(flags)

        # Send flags to submission server
        flag_responses = submit_flags(filtered_flags)

        # Print statistics
        print_statistics_from_flag_responses(flag_responses)

        # Wait for next round
        log.info("Waiting {} seconds before next round".format(ROUND_DELAY))
        time.sleep(ROUND_DELAY)
